# ANTI-PATTERNS RULES

# Anti-Patterns to Avoid

- ❌ Using `any` types without justification
- ❌ Direct DOM manipulation in React
- ❌ Using `window.confirm()` or `alert()`
- ❌ Unhandled promise rejections
- ❌ Inline styles in React components
- ❌ Hardcoded values in business logic
- ❌ Missing error boundaries
- ❌ Unvalidated user inputs
- ❌ Synchronous database operations
- ❌ Missing loading states


---

# CONTINUOUS-IMPROVEMENT RULES

# Continuous Improvement

- Regularly update dependencies
- Monitor performance metrics
- Review and refactor code
- Stay updated with best practices
- Gather user feedback
- Implement accessibility improvements


---

# DOCUMENTATION RULES

# Documentation Standards

## Automatic Documentation Updates
- **ALWAYS update documentation** when making code changes that affect:
  - API endpoints or GraphQL schema
  - Environment variables or configuration
  - New features or functionality
  - Breaking changes or deprecations
  - Security updates or changes
  - Database schema changes
  - New dependencies or removed dependencies

## Documentation Update Checklist
When making code changes, automatically check and update:
- [ ] **README.md** - Update relevant sections (features, setup, troubleshooting)
- [ ] **FEATURES.md** - Add new features or update existing ones
- [ ] **env.example** - Add new environment variables
- [ ] **API documentation** - Update GraphQL schema descriptions
- [ ] **Inline comments** - Add JSDoc comments for new functions
- [ ] **Type definitions** - Update TypeScript interfaces
- [ ] **Migration files** - Add descriptive comments for database changes

## Documentation Patterns
- **Keep documentation in sync** with code changes
- **Update examples** when API signatures change
- **Add troubleshooting notes** for common issues
- **Include usage examples** for new features
- **Document breaking changes** clearly
- **Update version requirements** when dependencies change

## Code-Documentation Synchronization
- **Before committing**: Review if documentation needs updates
- **For new features**: Document the feature, usage, and examples
- **For bug fixes**: Update troubleshooting sections if relevant
- **For refactoring**: Update affected documentation sections
- **For configuration changes**: Update setup and deployment docs


---

# EXPRESS-BACKEND RULES

# Express & Backend Standards

- Use Express 5 with proper middleware typing
- Implement comprehensive input validation with Joi
- Use rate limiting for security endpoints
- Implement proper error handling with logging
- Use Prisma for all database operations

## Database Naming Conventions

### PostgreSQL Schema Standards
- **ALWAYS use snake_case for table names and column names** in PostgreSQL
- Use `@@map("table_name")` directive to map Prisma model names to snake_case table names
- Use `@map("column_name")` directive to map Prisma field names to snake_case column names
- Maintain camelCase in Prisma schema for TypeScript compatibility
- Example:
  ```prisma
  model User {
    id        String   @id @default(uuid())
    createdAt DateTime @default(now()) @map("created_at")
    updatedAt DateTime @updatedAt @map("updated_at")
    firstName String?  @map("first_name")
    lastName  String?  @map("last_name")

    @@map("users")
  }
  ```

### Database Migration Standards
- When adding new models or fields, **ALWAYS include @map directives** for snake_case mapping
- Use descriptive migration names: `YYYYMMDDHHMMSS_descriptive_name`
- Test migrations on development database before applying to production
- Ensure all foreign key relationships use snake_case column names
- Maintain referential integrity with proper cascade rules


---

# FILE-ORGANIZATION RULES

# File Organization

## Frontend Structure
```
client/src/
├── components/     # Reusable UI components
├── pages/         # Page components
├── hooks/         # Custom React hooks
├── store/         # Redux store and slices
├── utils/         # Utility functions
├── types/         # TypeScript type definitions
└── __tests__/     # Test files
```

## Backend Structure
```
server/src/
├── auth/          # Authentication logic
├── config/        # Configuration files
├── middleware/    # Express middleware
├── resolvers/     # GraphQL resolvers
├── schema/        # GraphQL schema
├── utils/         # Utility functions
└── __tests__/     # Test files
```


---

# GRAPHQL RULES

# GraphQL & Apollo Standards

- Use GraphQL fragments for reusable queries
- Implement proper error handling in resolvers
- Use Apollo Client cache policies
- Define comprehensive TypeScript interfaces for all operations


---

# NAMING-STYLE-DOCS RULES

# Naming Conventions, Code Style, and Documentation

## Naming Conventions
- Use camelCase for variables and functions
- Use PascalCase for components and classes
- Use UPPER_SNAKE_CASE for constants
- Use descriptive, meaningful names

### Database Naming Conventions
- **ALWAYS use snake_case for PostgreSQL table names and column names**
- Use camelCase in Prisma schema for TypeScript compatibility
- Map Prisma fields to snake_case columns using `@map("column_name")`
- Map Prisma models to snake_case tables using `@@map("table_name")`
- Examples:
  - `createdAt` → `created_at`
  - `firstName` → `first_name`
  - `userId` → `user_id`
  - `isAdmin` → `is_admin`

## Code Style
- Use 2 spaces for indentation
- Use semicolons
- Use single quotes for strings
- Use trailing commas in objects and arrays
- Use template literals for string interpolation

## Documentation
- Write JSDoc comments for complex functions
- Document GraphQL schema with descriptions
- Keep README.md updated
- Document API endpoints
- Include usage examples


---

# PROJECT RULES

# Project Overview
This is a full-stack social and sports club management platform built with modern web technologies. Maintain enterprise-grade code quality with 0 ESLint errors.

# Architecture Principles

## Technology Stack
- Frontend: React 19, TypeScript, Apollo Client, Redux Toolkit
- Backend: Node.js, Express 5, GraphQL (Apollo Server), Prisma ORM
- Database: PostgreSQL, Redis
- Testing: Jest, Playwright, Supertest
- Code Quality: ESLint, Prettier, TypeScript strict mode

## Design Principles
- Type Safety First: Always use TypeScript with strict mode
- Zero ESLint Errors: Maintain 0 errors, warnings are acceptable for TypeScript `any` types only
- Import Organization: Follow ESLint import/order rules strictly
- Error Boundaries: Use React error boundaries with retry mechanisms
- Accessibility: WCAG compliance with Testing Library best practices
- Security: Input validation, rate limiting, secure authentication

# Development Workflow

## Before Committing
1. Run `npm run lint` (must have 0 errors)
2. Run `npm run type-check`
3. Run tests: `npm test`
4. Check accessibility: `npm run test:accessibility`
5. Verify build: `npm run build`
6. **Update documentation** if code changes affect features, APIs, or configuration

## Code Review Checklist
- [ ] TypeScript types are comprehensive
- [ ] Error handling is implemented
- [ ] Tests are written and passing
- [ ] Accessibility standards are met
- [ ] Security considerations are addressed
- [ ] Performance impact is considered
- [ ] **Documentation is updated** for any API, feature, or configuration changes


---

# REACT RULES

# React Coding Standards

- Use functional components with hooks
- Implement error boundaries with fallback UI
- Use React.memo for performance optimization
- Implement lazy loading with Suspense
- Replace `window.confirm()` with custom confirmation dialogs
- Use proper dependency arrays in useEffect


---

# SECURITY RULES

# Security Standards

## Authentication & Authorization
- Use JWT tokens with proper expiration
- Implement bcrypt for password hashing
- Use secure session management
- Implement rate limiting for auth endpoints
- Validate all inputs with Joi schemas

## Data Protection
- Use parameterized queries (Prisma handles this)
- Implement CORS properly
- Use security headers with Helmet
- Sanitize all user inputs
- Log security events


---

# TESTING RULES

# Testing Standards

- Write unit tests for all business logic
- Use Testing Library for React component testing
- Implement accessibility testing
- Use proper mocking strategies
- Maintain high test coverage

## Test Organization
- Unit tests for business logic
- Integration tests for API endpoints
- E2E tests for critical user flows
- Accessibility tests for UI components

## Test Patterns
- Use descriptive test names
- Follow AAA pattern (Arrange, Act, Assert)
- Mock external dependencies
- Test error scenarios
- Maintain test data fixtures


---

# TYPESCRIPT RULES

# TypeScript Coding Standards

- Use strict TypeScript configuration
- Define comprehensive interfaces for all GraphQL operations
- Avoid `any` types - use proper typing
- Use type guards and proper error handling
- Prefer interfaces over types for object shapes

## TypeScript Enforcement
- **ALWAYS use TypeScript (.ts/.tsx) for new files**
- **NEVER create JavaScript (.js/.jsx) files**
- **Convert any existing .js files to .ts when modifying them**
- **Use TypeScript for all scripts, utilities, and configuration files**
- **Prefer .ts over .js for any new development**


---

# UIUX RULES

# UI/UX Principles

## Accessibility
- Follow WCAG 2.1 AA guidelines
- Use semantic HTML elements
- Implement proper ARIA labels
- Ensure keyboard navigation
- Test with screen readers

## Design Patterns
- Use consistent component patterns
- Implement loading states
- Use proper error states
- Maintain responsive design
- Follow modern UI/UX practices


